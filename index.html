<!DOCTYPE html>
<meta charset="utf-8" />
<head>
  <style>
    html,
    body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      font-family: "Helvetica neue";
      background: #27343b;
      color: #fff;
      overflow-x: hidden;
    }

    main {
      display: grid;
      grid-template-rows: 100px 2fr 100px;
      height: 100vh;
    }

    .arc {
      fill: none;
      stroke-width: 5px;
      stroke-linecap: round;

      stroke: #0da6e0;
    }

    #runs-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }

    div.run {
      display: inline-block;
      padding: 0;
    }

    section {
      padding: 0px 40px;
    }

    text {
      font-size: 1.8em;
    }

    h1 {
      font-size: 5em;
      margin: 0 0 0px;
    }

    h2 {
      text-align: left;
      font-size: 6em;
      line-height: 100%;
      margin: 0;
    }

    h3 {
      text-align: left;
      font-size: 2.1em;
      line-height: 135%;
      margin: 0 0 15px;
      text-transform: uppercase;
    }

    .statsHolder:last-child h3 {
      margin-bottom: 20px;
    }

    .statsHolder {
      display: inline-block;
      margin: 0 70px 0 0;
      text-align: left;
      vertical-align: top;
    }

    .statsHolder:last-child {
      margin: 0;
    }

    svg.run-stats {
      width: 701px;
      display: inline-block;
      height: 44px;
      padding: 1px 0 0;
    }

    .run-stats text {
      font-style: normal;
      font-size: 2em;
    }

    p {
      margin: 0 0 5px;
      line-height: 135%;
    }

    #footer {
      display: flex;
      font-size: 0.5em;
      justify-content: space-between;
      align-items: end;
    }

    #footer h3 {
      margin: 0;
    }

    .run-distance {
      font-size: 1em;
      fill: #0da6e0;
    }
  </style>
</head>
<body>
  <main>
    <section>
      <h1>Runs</h1>
    </section>
    <section id="runs-container"></section>
    <section id="footer">
      <div id="year" class="stats">
        <h3>Year</h3>
        <h2>2019</h2>
      </div>
      <div id="name" class="stats">
        <h3>Athlete</h3>
        <h2>John Pham</h2>
      </div>
      <div id="distance" class="stats">
        <h3>Distance</h3>
        <h2>500 miles</h2>
      </div>
    </section>
  </main>

  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script>
    var runFiles = [
      "1600620885.gpx.geojson",
      "1611070683.gpx.geojson",
      "1615522128.gpx.geojson",
      "1649299598.gpx.geojson",
      "1655828005.gpx.geojson",
      "1657378380.gpx.geojson",
      "1657830074.gpx.geojson",
      "1659972209.gpx.geojson",
      "1672921725.gpx.geojson",
      "1674890336.gpx.geojson",
      "1687633805.gpx.geojson",
      "1690246343.gpx.geojson",
      "1692421493.gpx.geojson",
      "1696743889.gpx.geojson",
      "1696798153.gpx.geojson",
      "1734443454.gpx.geojson",
      "1734597372.gpx.geojson"
    ];

    var width = 230,
      height = 230;

    var container = document.getElementById("runs-container");
    var runInfo = [];

    for (var i = 0; i < runFiles.length; i++) {
      d3.json("./data/" + runFiles[i], function(error, run) {
        var time = run.features[0].properties.time;
        var distance = totalDistance(run.features[0].geometry.coordinates);

        drawRun(run, distance, time); //load the json data
      });
    }

    function drawRun(runData, distance, time) {
      var runDiv = document.createElement("div");
      runDiv.className = "run";
      runDiv.dataset.runDistance = distance;
      runDiv.dataset.runDate = time;

      container.appendChild(runDiv);

      var projection = d3.geo
        .mercator()
        .scale(1)
        .translate([0, 0]);

      var path = d3.geo.path().projection(projection);

      // Compute the bounds of a feature of interest, then derive scale & translate.
      var b = path.bounds(runData),
        s =
          0.95 /
          Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
        t = [
          (width - s * (b[1][0] + b[0][0])) / 2,
          (height - s * (b[1][1] + b[0][1])) / 2
        ];

      // Update the projection to use computed scale & translate.
      projection.scale(s).translate(t);

      var svg = d3
        .select(runDiv)
        .append("svg")
        .attr("class", "run-svg")
        .attr("width", width)
        .attr("height", height);

      svg
        .append("path")
        .datum(runData)
        .attr("class", "arc")
        .attr("d", path);

      // svg
      //   .append("text")
      //   .text(distance)
      //   .attr("x", 10)
      //   .attr("y", 20)
      //   .attr("class", "run-distance");

      // Sort them
      sortMaps();
    }

    function sortMaps() {
      var runDivs = document.getElementsByClassName("run");

      if (runDivs.length === runFiles.length) {
        var runs = sortedRunsArray();
        runs.forEach(function(run, index) {
          container.appendChild(run);
        });
      }
    }

    function sortedRunsArray(sort) {
      var sort = typeof sort !== "undefined" ? sort : "date",
        runDivs = document.getElementsByClassName("run"),
        runs = [];

      for (var i = 0; i < runDivs.length; ++i) {
        runs.push(runDivs[i]);
      }

      runs.sort(function(a, b) {
        if (sort == "distance") {
          return (
            parseFloat(a.dataset.runDistance) -
            parseFloat(b.dataset.runDistance)
          );
        } else {
          return a.dataset.runDate.localeCompare(b.dataset.runDate);
        }
      });

      return runs;
    }

    function totalDistance(coords) {
      var totalDist = 0;

      for (var i = 0; i < coords.length - 1; ++i) {
        var p1 = [coords[i][0], coords[i][1]];
        var p2 = [coords[i + 1][0], coords[i + 1][1]];

        totalDist += calcDist(p1, p2);
      }

      return totalDist.toFixed(2);
    }

    function calcDist(p1, p2) {
      // Haversine formula
      dLatRad = (Math.abs(p1[1] - p2[1]) * Math.PI) / 180;
      dLonRad = (Math.abs(p1[0] - p2[0]) * Math.PI) / 180;
      // Calculate origin in Radians
      lat1Rad = (p1[1] * Math.PI) / 180;
      lon1Rad = (p1[0] * Math.PI) / 180;
      // Calculate new point in Radians
      lat2Rad = (p2[1] * Math.PI) / 180;
      lon2Rad = (p2[0] * Math.PI) / 180;

      // Earth's Radius
      eR = 6371;
      d1 =
        Math.sin(dLatRad / 2) * Math.sin(dLatRad / 2) +
        Math.sin(dLonRad / 2) *
          Math.sin(dLonRad / 2) *
          Math.cos(lat1Rad) *
          Math.cos(lat2Rad);
      d2 = 2 * Math.atan2(Math.sqrt(d1), Math.sqrt(1 - d1));
      return eR * d2;
    }

    d3.select(self.frameElement).style("height", height + "px");
  </script>
</body>
